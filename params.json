{"name":"Wookiee-cache","tagline":"Wookiee Component - Cache","body":"#Wookiee - Component Caching\r\n\r\n[![Build Status](https://travis-ci.org/Webtrends/wookiee-cache.svg?branch=master)](https://travis-ci.org/Webtrends/wookiee-cache) [![Coverage Status](https://coveralls.io/repos/Webtrends/wookiee-cache/badge.svg?branch=master&service=github)](https://coveralls.io/github/Webtrends/wookiee-cache?branch=master) [![Latest Release](https://img.shields.io/github/release/webtrends/wookiee-cache.svg)](https://github.com/Webtrends/wookiee-cache/releases) [![License](http://img.shields.io/:license-Apache%202-red.svg)](http://www.apache.org/licenses/LICENSE-2.0.txt)\r\n\r\n[Main Wookiee Project](https://github.com/Webtrends/wookiee)\r\n\r\nFor Configuration information see [Caching Config](docs/config.md)\r\n\r\n##Creating a Cache\r\n\r\nBefore we can create cache objects, we need to do the following:\r\n\r\n* Add dependency to service pom\r\n* Enable the CacheManager system component\r\n* Initialize the cache in our service\r\n\r\n###Adding dependency to service POM\r\n\r\nTo add Wookiee caching you need to include the dependency into your maven pom, like below:\r\n```\r\n<dependency>\r\n  <groupId>com.webtrends</groupId>\r\n  <artifactId>wookiee-cache</artifactId>\r\n  <version>${platform.version}</version>\r\n</dependency>\r\n```\r\nThis would then download the libraries that allow using the Cacheable Trait. By default this would only give you access to the in memory cache, which is not incredibly useful for most cases. Generally a specific caching module would be used that would depend on the module above. Currently there is a memcache module for use that you can use in your project by adding the following dependency:\r\n```\r\n<dependency>\r\n  <groupId>com.webtrends</groupId>\r\n  <artifactId>wookiee-cache-memcache</artifactId>\r\n  <version>${platform.version}</version>\r\n</dependency>\r\n```\r\nNOTE: If you use the above dependency you do not need the wookiee-cache dependency as it will be automatically used from the wookiee-cache-memcache module, and this should apply for any caching module that may be included later.\r\n\r\n###Enable Caching system component\r\n\r\nIf you wish to use the in-memory caching scheme, then you would enable the component in wookiee-cache.conf:\r\n```\r\nwookiee-cache {\r\n  manager = \"com.webtrends.harness.component.cache.memory.MemoryManager\"\r\n  enabled = true\r\n}\r\n```\r\nIf you wish to use the memcache component, then you would enable the component in wookiee-cache-memcache.conf:\r\n```\r\nwookiee-cache-memcache {\r\n  manager = \"com.webtrends.harness.component.memcache.MemcacheManager\"\r\n  enabled = true\r\n}\r\n```\r\n\r\nMost of the configuration for Memcache itself would be defined by the application and not by Wookiee. Wookiee config simply loads up the manager for the clients, not the clients themselves. \r\n\r\n###Initializing a Cache\r\n\r\nTo actually be able to get and set to a Cache you need to initialize a cache in the CacheManager. Currently the only cache to use would be the MemcacheManager, which obviously requires Memcache servers to work correctly. Each cache that is initialized can be set to a different Memcache server, or they can all point to the same source, it is completely up to the developer and the requirements of the work. \r\nThe following code snippet would initialize a Memcache Client:\r\n```\r\n// build the cache for the report data\r\nval manager = context.actorSelection(\"/user/\" + classOf[MemcacheManager].getName)\r\nval config = CacheConfig(\r\n  namespace = LookupConstants.MemcacheCacheName,\r\n  props = Some(Map(\"serverList\" -> context.system.settings.config.getString(LookupConstants.KeyMemcacheServer)))\r\n)\r\nmanager ! CreateCache(config) // let MemcacheManager handle the exceptions if any\r\n```\r\nLet's go through this line by line.\r\n\r\n* Line 1: This calls the MemcacheManager that was loaded as a Actor SystemComponent. This what we will be using to make all our calls for MemCache\r\n* Line 2: Create a CacheConfig object, which holds all relevant information for creating a cache.\r\n* Line 3: Raise an event to the MemcacheManager to create a cache with the config supplied.\r\n\r\nOnce the cache is supplied you can use the following events against the MemcacheManager:\r\n\r\n* CreateCache(config:Config) - Creates a cache with the supplied configuration\r\n* Get - retrieves an object stored in the cache\r\n* Add - Adds an object to the cache\r\n* Delete - Deletes an object from the cache\r\n* Decrement - Creates an integer based object in the cache and decrements the value\r\n* Increment - Creates an integer based object in the cache and increments the value\r\n* Contains - Checks to see whether an object is in the cache\r\n* Clear - Clears the cache\r\n\r\nWith this you can perform basic functionality against the newly created cache. However if you are dealing with a specific object you are trying to store in the cache, you can more easily manage that through the Cacheable object trait. This will then handle all the serializing and deserializing of the object to and from the cache.\r\n\r\n##Creating a Cacheable Object\r\nA cacheable object is simply an object that uses the Cacheable trait from the wookiee-cache library. Once an object is cacheable it provides two methods that you don't need to implement as the base implementations will write to the cache and read from the cache without any further code.\r\nThe cacheable object is required to implement two methods:\r\n\r\n* key - This function simply returns the key for the object, the cache functions from the cacheable trait allow for sending in the key for each function call, so you can simply return empty string if you don't plan on internalizing the key\r\n* namespace - This is required and should be defined based on the namespace that was supplied to the cache when it was created.\r\n\r\n```\r\ndef readFromCache(cacheRef:ActorSelection, cacheKey:Option[String])\r\n      (implicit timeout:Timeout, executor:ExecutionContext, m:Manifest[T]) : Future[Option[T]]\r\n```\r\nThe readFromCache will then require the reference to the Actor for the CacheManager, which can be either and ActorRef or an ActorSelection object. The cacheKey can be left as NONE if the key for the object is defined correctly by the key function in your cacheable object.\r\n```\r\ndef writeInCache(cacheRef:ActorSelection, cacheKey:Option[String])\r\n      (implicit timeout:Timeout, executor:ExecutionContext) : Unit\r\n```\r\nThe writeInCache will take the same parameters as readFromCache and simply write the current object to the cache. So there would be a little up front work to find the actor, otherwise you can simply use the Cacheable trait and call these two functions to get and set your object into a cache.\r\n\r\n###Data Timeout\r\nBy default an object will remain in cache until it is either specifically deleted from the cache, or in the case of Memcache, until the servers are restarted. (The Memcache servers, not Wookiee) \r\nThis is not always the best approach, so another way is to allow the user to set how long the object will remain in the cache until it is evicted. The dataTimeout method returns a Long in milliseconds to define that time. Every time an object is stored in the cache it wraps the object and places the current time into the wrapped object. When the object is retrieved it checks to see whether the objects insertion time is older than the current time minus the timeout value retrieved from the dataTimeout method on the object. If it is the object is rejected and deleted and NONE is returned.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}